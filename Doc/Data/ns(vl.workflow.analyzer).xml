<?xml version="1.0" encoding="utf-8"?>
<Namespace DisplayName="::vl::workflow::analyzer">
  <Overloads DisplayName="BuildGlobalNameFromModules function">
    <Symbol Key="::vl::workflow::analyzer::BuildGlobalNameFromModules(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.BuildGlobalNameFromModules(^ WfLexicalScopeManager)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildGlobalNameFromTypeDescriptors function">
    <Symbol Key="::vl::workflow::analyzer::BuildGlobalNameFromTypeDescriptors(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.BuildGlobalNameFromTypeDescriptors(^ WfLexicalScopeManager)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildNameForDeclaration function">
    <Symbol Key="::vl::workflow::analyzer::BuildNameForDeclaration(* WfLexicalScopeManager,Ptr&lt;WfLexicalScopeName&gt;,* WfDeclaration)" UrlName="vl.workflow.analyzer.BuildNameForDeclaration(^ WfLexicalScopeManager,Ptr{WfLexicalScopeName},^ WfDeclaration)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildScopeForDeclaration function">
    <Symbol Key="::vl::workflow::analyzer::BuildScopeForDeclaration(* WfLexicalScopeManager,Ptr&lt;WfLexicalScope&gt;,Ptr&lt;WfDeclaration&gt;,* parsing::ParsingTreeCustomBase)" UrlName="vl.workflow.analyzer.BuildScopeForDeclaration(^ WfLexicalScopeManager,Ptr{WfLexicalScope},Ptr{WfDeclaration},^ parsing.ParsingTreeCustomBase)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildScopeForExpression function">
    <Symbol Key="::vl::workflow::analyzer::BuildScopeForExpression(* WfLexicalScopeManager,Ptr&lt;WfLexicalScope&gt;,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.BuildScopeForExpression(^ WfLexicalScopeManager,Ptr{WfLexicalScope},Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildScopeForModule function">
    <Symbol Key="::vl::workflow::analyzer::BuildScopeForModule(* WfLexicalScopeManager,Ptr&lt;WfModule&gt;)" UrlName="vl.workflow.analyzer.BuildScopeForModule(^ WfLexicalScopeManager,Ptr{WfModule})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildScopeForStatement function">
    <Symbol Key="::vl::workflow::analyzer::BuildScopeForStatement(* WfLexicalScopeManager,Ptr&lt;WfLexicalScope&gt;,Ptr&lt;WfStatement&gt;)" UrlName="vl.workflow.analyzer.BuildScopeForStatement(^ WfLexicalScopeManager,Ptr{WfLexicalScope},Ptr{WfStatement})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CanConvertToType function">
    <Symbol Key="::vl::workflow::analyzer::CanConvertToType(* reflection::description::ITypeInfo,* reflection::description::ITypeInfo,bool)" UrlName="vl.workflow.analyzer.CanConvertToType(^ reflection.description.ITypeInfo,^ reflection.description.ITypeInfo,bool)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CheckScopes_CycleDependency function">
    <Symbol Key="::vl::workflow::analyzer::CheckScopes_CycleDependency(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.CheckScopes_CycleDependency(^ WfLexicalScopeManager)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CheckScopes_DuplicatedSymbol function">
    <Symbol Key="::vl::workflow::analyzer::CheckScopes_DuplicatedSymbol(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.CheckScopes_DuplicatedSymbol(^ WfLexicalScopeManager)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CheckScopes_SymbolType function">
    <Symbol Key="::vl::workflow::analyzer::CheckScopes_SymbolType(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.CheckScopes_SymbolType(^ WfLexicalScopeManager)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CompleteScopeForClassMember function">
    <Symbol Key="::vl::workflow::analyzer::CompleteScopeForClassMember(* WfLexicalScopeManager,Ptr&lt;typeimpl::WfCustomType&gt;,Ptr&lt;WfClassDeclaration&gt;,Ptr&lt;WfDeclaration&gt;)" UrlName="vl.workflow.analyzer.CompleteScopeForClassMember(^ WfLexicalScopeManager,Ptr{typeimpl.WfCustomType},Ptr{WfClassDeclaration},Ptr{WfDeclaration})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CompleteScopeForDeclaration function">
    <Symbol Key="::vl::workflow::analyzer::CompleteScopeForDeclaration(* WfLexicalScopeManager,Ptr&lt;WfDeclaration&gt;)" UrlName="vl.workflow.analyzer.CompleteScopeForDeclaration(^ WfLexicalScopeManager,Ptr{WfDeclaration})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CompleteScopeForModule function">
    <Symbol Key="::vl::workflow::analyzer::CompleteScopeForModule(* WfLexicalScopeManager,Ptr&lt;WfModule&gt;)" UrlName="vl.workflow.analyzer.CompleteScopeForModule(^ WfLexicalScopeManager,Ptr{WfModule})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ContextFreeDeclarationDesugar function">
    <Symbol Key="::vl::workflow::analyzer::ContextFreeDeclarationDesugar(* WfLexicalScopeManager,Ptr&lt;WfDeclaration&gt;)" UrlName="vl.workflow.analyzer.ContextFreeDeclarationDesugar(^ WfLexicalScopeManager,Ptr{WfDeclaration})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ContextFreeExpressionDesugar function">
    <Symbol Key="::vl::workflow::analyzer::ContextFreeExpressionDesugar(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.ContextFreeExpressionDesugar(^ WfLexicalScopeManager,Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ContextFreeModuleDesugar function">
    <Symbol Key="::vl::workflow::analyzer::ContextFreeModuleDesugar(* WfLexicalScopeManager,Ptr&lt;WfModule&gt;)" UrlName="vl.workflow.analyzer.ContextFreeModuleDesugar(^ WfLexicalScopeManager,Ptr{WfModule})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ContextFreeStatementDesugar function">
    <Symbol Key="::vl::workflow::analyzer::ContextFreeStatementDesugar(* WfLexicalScopeManager,Ptr&lt;WfStatement&gt;)" UrlName="vl.workflow.analyzer.ContextFreeStatementDesugar(^ WfLexicalScopeManager,Ptr{WfStatement})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyDeclaration function">
    <Symbol Key="::vl::workflow::analyzer::CopyDeclaration(Ptr&lt;WfDeclaration&gt;,bool)" UrlName="vl.workflow.analyzer.CopyDeclaration(Ptr{WfDeclaration},bool)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyExpression function">
    <Symbol Key="::vl::workflow::analyzer::CopyExpression(Ptr&lt;WfExpression&gt;,bool)" UrlName="vl.workflow.analyzer.CopyExpression(Ptr{WfExpression},bool)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyModule function">
    <Symbol Key="::vl::workflow::analyzer::CopyModule(Ptr&lt;WfModule&gt;,bool)" UrlName="vl.workflow.analyzer.CopyModule(Ptr{WfModule},bool)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyStatement function">
    <Symbol Key="::vl::workflow::analyzer::CopyStatement(Ptr&lt;WfStatement&gt;,bool)" UrlName="vl.workflow.analyzer.CopyStatement(Ptr{WfStatement},bool)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyType function">
    <Symbol Key="::vl::workflow::analyzer::CopyType(Ptr&lt;WfType&gt;)" UrlName="vl.workflow.analyzer.CopyType(Ptr{WfType})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyTypeInfo function">
    <Symbol Key="::vl::workflow::analyzer::CopyTypeInfo(* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.CopyTypeInfo(^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyWithExpandVirtualVisitor class">
    <Symbol Key="::vl::workflow::analyzer::CopyWithExpandVirtualVisitor" UrlName="vl.workflow.analyzer.CopyWithExpandVirtualVisitor" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CreateDefaultValue function">
    <Symbol Key="::vl::workflow::analyzer::CreateDefaultValue(* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.CreateDefaultValue(^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CreateTypeInfoFromMethodInfo function">
    <Symbol Key="::vl::workflow::analyzer::CreateTypeInfoFromMethodInfo(* reflection::description::IMethodInfo)" UrlName="vl.workflow.analyzer.CreateTypeInfoFromMethodInfo(^ reflection.description.IMethodInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CreateTypeInfoFromType function">
    <Symbol Key="::vl::workflow::analyzer::CreateTypeInfoFromType(* WfLexicalScope,Ptr&lt;WfType&gt;)" UrlName="vl.workflow.analyzer.CreateTypeInfoFromType(^ WfLexicalScope,Ptr{WfType})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CreateTypeInfoFromTypeFlag function">
    <Symbol Key="::vl::workflow::analyzer::CreateTypeInfoFromTypeFlag(TypeFlag)" UrlName="vl.workflow.analyzer.CreateTypeInfoFromTypeFlag(TypeFlag)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ExpandBindExpression function">
    <Symbol Key="::vl::workflow::analyzer::ExpandBindExpression(* WfLexicalScopeManager,* WfBindExpression)" UrlName="vl.workflow.analyzer.ExpandBindExpression(^ WfLexicalScopeManager,^ WfBindExpression)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ExpandCoOperatorExpression function">
    <Symbol Key="::vl::workflow::analyzer::ExpandCoOperatorExpression(* WfLexicalScopeManager,* WfCoOperatorExpression)" UrlName="vl.workflow.analyzer.ExpandCoOperatorExpression(^ WfLexicalScopeManager,^ WfCoOperatorExpression)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ExpandCoProviderStatement function">
    <Symbol Key="::vl::workflow::analyzer::ExpandCoProviderStatement(* WfLexicalScopeManager,* WfCoProviderStatement)" UrlName="vl.workflow.analyzer.ExpandCoProviderStatement(^ WfLexicalScopeManager,^ WfCoProviderStatement)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ExpandForEachStatement function">
    <Symbol Key="::vl::workflow::analyzer::ExpandForEachStatement(* WfLexicalScopeManager,* WfForEachStatement)" UrlName="vl.workflow.analyzer.ExpandForEachStatement(^ WfLexicalScopeManager,^ WfForEachStatement)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ExpandMixinCastExpression function">
    <Symbol Key="::vl::workflow::analyzer::ExpandMixinCastExpression(* WfLexicalScopeManager,* WfMixinCastExpression)" UrlName="vl.workflow.analyzer.ExpandMixinCastExpression(^ WfLexicalScopeManager,^ WfMixinCastExpression)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ExpandNewCoroutineExpression function">
    <Symbol Key="::vl::workflow::analyzer::ExpandNewCoroutineExpression(* WfLexicalScopeManager,* WfNewCoroutineExpression)" UrlName="vl.workflow.analyzer.ExpandNewCoroutineExpression(^ WfLexicalScopeManager,^ WfNewCoroutineExpression)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ExpandStateMachine function">
    <Symbol Key="::vl::workflow::analyzer::ExpandStateMachine(* WfLexicalScopeManager,* WfStateMachineDeclaration)" UrlName="vl.workflow.analyzer.ExpandStateMachine(^ WfLexicalScopeManager,^ WfStateMachineDeclaration)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ExpandSwitchStatement function">
    <Symbol Key="::vl::workflow::analyzer::ExpandSwitchStatement(* WfLexicalScopeManager,* WfSwitchStatement)" UrlName="vl.workflow.analyzer.ExpandSwitchStatement(^ WfLexicalScopeManager,^ WfSwitchStatement)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="FindInterfaceConstructor function">
    <Symbol Key="::vl::workflow::analyzer::FindInterfaceConstructor(* reflection::description::ITypeDescriptor)" UrlName="vl.workflow.analyzer.FindInterfaceConstructor(^ reflection.description.ITypeDescriptor)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetEnumerableExpressionItemType function">
    <Symbol Key="::vl::workflow::analyzer::GetEnumerableExpressionItemType(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;)" UrlName="vl.workflow.analyzer.GetEnumerableExpressionItemType(^ WfLexicalScopeManager,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionEventInfo function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionEventInfo(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.GetExpressionEventInfo(^ WfLexicalScopeManager,Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionFromTypeDescriptor function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionFromTypeDescriptor(* reflection::description::ITypeDescriptor)" UrlName="vl.workflow.analyzer.GetExpressionFromTypeDescriptor(^ reflection.description.ITypeDescriptor)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionName function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionName(Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.GetExpressionName(Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionScopeName function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionScopeName(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.GetExpressionScopeName(^ WfLexicalScopeManager,Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionType function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionType(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;)" UrlName="vl.workflow.analyzer.GetExpressionType(^ WfLexicalScopeManager,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionTypes function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionTypes(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;,bool,&amp; collections::List&lt;ResolveExpressionResult&gt;)" UrlName="vl.workflow.analyzer.GetExpressionTypes(^ WfLexicalScopeManager,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo},bool,&amp; collections.List{ResolveExpressionResult})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetLeftValueExpressionType function">
    <Symbol Key="::vl::workflow::analyzer::GetLeftValueExpressionType(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.GetLeftValueExpressionType(^ WfLexicalScopeManager,Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetMergedType function">
    <Symbol Key="::vl::workflow::analyzer::GetMergedType(Ptr&lt;reflection::description::ITypeInfo&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;)" UrlName="vl.workflow.analyzer.GetMergedType(Ptr{reflection.description.ITypeInfo},Ptr{reflection.description.ITypeInfo})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetScopeNameFromReferenceType function">
    <Symbol Key="::vl::workflow::analyzer::GetScopeNameFromReferenceType(* WfLexicalScope,Ptr&lt;WfType&gt;)" UrlName="vl.workflow.analyzer.GetScopeNameFromReferenceType(^ WfLexicalScope,Ptr{WfType})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetTypeFlag function">
    <Symbol Key="::vl::workflow::analyzer::GetTypeFlag(* reflection::description::ITypeDescriptor)" UrlName="vl.workflow.analyzer.GetTypeFlag(^ reflection.description.ITypeDescriptor)" Doc="false" />
    <Symbol Key="::vl::workflow::analyzer::GetTypeFlag(* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.GetTypeFlag(^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetTypeFragments function">
    <Symbol Key="::vl::workflow::analyzer::GetTypeFragments(* reflection::description::ITypeDescriptor,&amp; collections::List&lt;WString&gt;)" UrlName="vl.workflow.analyzer.GetTypeFragments(^ reflection.description.ITypeDescriptor,&amp; collections.List{WString})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetTypeFromTypeInfo function">
    <Symbol Key="::vl::workflow::analyzer::GetTypeFromTypeInfo(* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.GetTypeFromTypeInfo(^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="IsExpressionDependOnExpectedType function">
    <Symbol Key="::vl::workflow::analyzer::IsExpressionDependOnExpectedType(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.IsExpressionDependOnExpectedType(^ WfLexicalScopeManager,Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="IsNullAcceptableType function">
    <Symbol Key="::vl::workflow::analyzer::IsNullAcceptableType(* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.IsNullAcceptableType(^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="IsSameType function">
    <Symbol Key="::vl::workflow::analyzer::IsSameType(* reflection::description::ITypeInfo,* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.IsSameType(^ reflection.description.ITypeInfo,^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ResolveExpressionResult struct">
    <Symbol Key="::vl::workflow::analyzer::ResolveExpressionResult" UrlName="vl.workflow.analyzer.ResolveExpressionResult" Doc="false" />
  </Overloads>
  <Overloads DisplayName="SearchOrderedName function">
    <Symbol Key="::vl::workflow::analyzer::SearchOrderedName(* WfLexicalScope,Ptr&lt;WfExpression&gt;,&amp; collections::SortedList&lt;vint&gt;)" UrlName="vl.workflow.analyzer.SearchOrderedName(^ WfLexicalScope,Ptr{WfExpression},&amp; collections.SortedList{vint})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="SearchUntilNonVirtualStatement function">
    <Symbol Key="::vl::workflow::analyzer::SearchUntilNonVirtualStatement(Ptr&lt;WfStatement&gt;)" UrlName="vl.workflow.analyzer.SearchUntilNonVirtualStatement(Ptr{WfStatement})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="SelectFunction function">
    <Symbol Key="::vl::workflow::analyzer::SelectFunction(* WfLexicalScopeManager,* parsing::ParsingTreeCustomBase,Ptr&lt;WfExpression&gt;,&amp; collections::List&lt;ResolveExpressionResult&gt;,&amp; collections::List&lt;Ptr&lt;WfExpression&gt;&gt;,&amp; vint)" UrlName="vl.workflow.analyzer.SelectFunction(^ WfLexicalScopeManager,^ parsing.ParsingTreeCustomBase,Ptr{WfExpression},&amp; collections.List{ResolveExpressionResult},&amp; collections.List{Ptr{WfExpression}},&amp; vint)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="SetCodeRange function">
    <Symbol Key="::vl::workflow::analyzer::SetCodeRange(Ptr&lt;WfType&gt;,parsing::ParsingTextRange,bool)" UrlName="vl.workflow.analyzer.SetCodeRange(Ptr{WfType},parsing.ParsingTextRange,bool)" Doc="false" />
    <Symbol Key="::vl::workflow::analyzer::SetCodeRange(Ptr&lt;WfExpression&gt;,parsing::ParsingTextRange,bool)" UrlName="vl.workflow.analyzer.SetCodeRange(Ptr{WfExpression},parsing.ParsingTextRange,bool)" Doc="false" />
    <Symbol Key="::vl::workflow::analyzer::SetCodeRange(Ptr&lt;WfStatement&gt;,parsing::ParsingTextRange,bool)" UrlName="vl.workflow.analyzer.SetCodeRange(Ptr{WfStatement},parsing.ParsingTextRange,bool)" Doc="false" />
    <Symbol Key="::vl::workflow::analyzer::SetCodeRange(Ptr&lt;WfDeclaration&gt;,parsing::ParsingTextRange,bool)" UrlName="vl.workflow.analyzer.SetCodeRange(Ptr{WfDeclaration},parsing.ParsingTextRange,bool)" Doc="false" />
    <Symbol Key="::vl::workflow::analyzer::SetCodeRange(Ptr&lt;WfModule&gt;,parsing::ParsingTextRange,bool)" UrlName="vl.workflow.analyzer.SetCodeRange(Ptr{WfModule},parsing.ParsingTextRange,bool)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="TypeFlag enum">
    <Symbol Key="::vl::workflow::analyzer::TypeFlag" UrlName="vl.workflow.analyzer.TypeFlag" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateClassMemberSemantic function">
    <Symbol Key="::vl::workflow::analyzer::ValidateClassMemberSemantic(* WfLexicalScopeManager,Ptr&lt;typeimpl::WfCustomType&gt;,Ptr&lt;WfClassDeclaration&gt;,Ptr&lt;WfDeclaration&gt;)" UrlName="vl.workflow.analyzer.ValidateClassMemberSemantic(^ WfLexicalScopeManager,Ptr{typeimpl.WfCustomType},Ptr{WfClassDeclaration},Ptr{WfDeclaration})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateConstantExpression function">
    <Symbol Key="::vl::workflow::analyzer::ValidateConstantExpression(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;)" UrlName="vl.workflow.analyzer.ValidateConstantExpression(^ WfLexicalScopeManager,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateDeclarationSemantic function">
    <Symbol Key="::vl::workflow::analyzer::ValidateDeclarationSemantic(* WfLexicalScopeManager,Ptr&lt;WfDeclaration&gt;)" UrlName="vl.workflow.analyzer.ValidateDeclarationSemantic(^ WfLexicalScopeManager,Ptr{WfDeclaration})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateDeclarationStructure function">
    <Symbol Key="::vl::workflow::analyzer::ValidateDeclarationStructure(* WfLexicalScopeManager,Ptr&lt;WfDeclaration&gt;,* WfClassDeclaration,* WfExpression)" UrlName="vl.workflow.analyzer.ValidateDeclarationStructure(^ WfLexicalScopeManager,Ptr{WfDeclaration},^ WfClassDeclaration,^ WfExpression)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateExpressionSemantic function">
    <Symbol Key="::vl::workflow::analyzer::ValidateExpressionSemantic(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;,&amp; collections::List&lt;ResolveExpressionResult&gt;)" UrlName="vl.workflow.analyzer.ValidateExpressionSemantic(^ WfLexicalScopeManager,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo},&amp; collections.List{ResolveExpressionResult})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateExpressionStructure function">
    <Symbol Key="::vl::workflow::analyzer::ValidateExpressionStructure(* WfLexicalScopeManager,* ValidateStructureContext,&amp; Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.ValidateExpressionStructure(^ WfLexicalScopeManager,^ ValidateStructureContext,&amp; Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateModuleSemantic function">
    <Symbol Key="::vl::workflow::analyzer::ValidateModuleSemantic(* WfLexicalScopeManager,Ptr&lt;WfModule&gt;)" UrlName="vl.workflow.analyzer.ValidateModuleSemantic(^ WfLexicalScopeManager,Ptr{WfModule})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateModuleStructure function">
    <Symbol Key="::vl::workflow::analyzer::ValidateModuleStructure(* WfLexicalScopeManager,Ptr&lt;WfModule&gt;)" UrlName="vl.workflow.analyzer.ValidateModuleStructure(^ WfLexicalScopeManager,Ptr{WfModule})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateScopeName function">
    <Symbol Key="::vl::workflow::analyzer::ValidateScopeName(* WfLexicalScopeManager,Ptr&lt;WfLexicalScopeName&gt;)" UrlName="vl.workflow.analyzer.ValidateScopeName(^ WfLexicalScopeManager,Ptr{WfLexicalScopeName})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateStatementSemantic function">
    <Symbol Key="::vl::workflow::analyzer::ValidateStatementSemantic(* WfLexicalScopeManager,Ptr&lt;WfStatement&gt;)" UrlName="vl.workflow.analyzer.ValidateStatementSemantic(^ WfLexicalScopeManager,Ptr{WfStatement})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateStatementStructure function">
    <Symbol Key="::vl::workflow::analyzer::ValidateStatementStructure(* WfLexicalScopeManager,* ValidateStructureContext,&amp; Ptr&lt;WfStatement&gt;)" UrlName="vl.workflow.analyzer.ValidateStatementStructure(^ WfLexicalScopeManager,^ ValidateStructureContext,&amp; Ptr{WfStatement})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateStructureContext struct">
    <Symbol Key="::vl::workflow::analyzer::ValidateStructureContext" UrlName="vl.workflow.analyzer.ValidateStructureContext" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateTypeStragety enum">
    <Symbol Key="::vl::workflow::analyzer::ValidateTypeStragety" UrlName="vl.workflow.analyzer.ValidateTypeStragety" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateTypeStructure function">
    <Symbol Key="::vl::workflow::analyzer::ValidateTypeStructure(* WfLexicalScopeManager,Ptr&lt;WfType&gt;,ValidateTypeStragety,* WfClassDeclaration)" UrlName="vl.workflow.analyzer.ValidateTypeStructure(^ WfLexicalScopeManager,Ptr{WfType},ValidateTypeStragety,^ WfClassDeclaration)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfErrors struct">
    <Symbol Key="::vl::workflow::analyzer::WfErrors" UrlName="vl.workflow.analyzer.WfErrors" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfLexicalCapture struct">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalCapture" UrlName="vl.workflow.analyzer.WfLexicalCapture" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfLexicalFunctionConfig class">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalFunctionConfig" UrlName="vl.workflow.analyzer.WfLexicalFunctionConfig" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfLexicalScope class">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalScope" UrlName="vl.workflow.analyzer.WfLexicalScope" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfLexicalScopeManager class">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalScopeManager" UrlName="vl.workflow.analyzer.WfLexicalScopeManager" Doc="true" />
  </Overloads>
  <Overloads DisplayName="WfLexicalScopeName class">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalScopeName" UrlName="vl.workflow.analyzer.WfLexicalScopeName" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfLexicalSymbol class">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalSymbol" UrlName="vl.workflow.analyzer.WfLexicalSymbol" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfStateMachineInfo struct">
    <Symbol Key="::vl::workflow::analyzer::WfStateMachineInfo" UrlName="vl.workflow.analyzer.WfStateMachineInfo" Doc="false" />
  </Overloads>
</Namespace>