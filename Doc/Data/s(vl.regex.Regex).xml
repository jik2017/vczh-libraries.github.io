<?xml version="1.0" encoding="utf-8"?>
<OverloadingSymbols>
  <Symbols Key="vl.regex.Regex">
    <ClassDecl Access="Public" Name="Regex" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex" OverloadKey="::vl::regex::Regex" ClassType="Class">
      <Document>&lt;Document&gt;
  &lt;summary&gt;
Regular Expression. Here is a brief description of the regular expression grammar:
1) Charset:
	a, [a-z], [^a-z]
2) Functional characters:
	^: the beginning of the input (DFA incompatible)
	$: the end of the input (DFA incompatible)
	regex1|regex2: match either regex1 or regex2
3) Escaping (both \ and / mean the next character is escaped)
	Escaped characters:
		\r: the CR character
		\n: the LF character
		\t: the tab character
		\s: spacing characters (including space, \r, \n, \t)
		\S: non-spacing characters
		\d: [0-9]
		\D: [^0-9]
		\l: [a-zA-Z]
		\L: [^a-zA-Z]
		\w: [a-zA-Z0-9_]
		\W: [^a-zA-Z0-9_]
		\.: any character (this is the main different from other regex, which treat "." as any characters and "\." as the dot character)
		\\, \/, \(, \), \+, \*, \?, \{, \}, \[, \], \&amp;lt;, \&amp;gt;, \^, \$, \!, \=: represents itself
	Escaped characters in charset defined in a square bracket:
		\r: the CR character
		\n: the LF character
		\t: the tab character
		\-, \[, \], \\, \/, \^, \$: represents itself
4) Loops:
	regex{3}: repeats 3 times
	regex{3,}: repeats 3 or more times
	regex{1,3}: repeats 1 to 3 times
	regex?: repeats 0 or 1 times
	regex*: repeats 0 or more times
	regex+: repeats 1 or more times
	if you add a "?" right after a loop, it means repeating as less as possible (DFA incompatible)
5) Capturing: (DFA incompatible)
	(regex): No capturing, just change the operators' association
	(?regex): Capture matched fragment
	(&amp;lt;name&amp;gt;regex): Capture matched fragment in a named group called "name"
	(&amp;lt;$i&amp;gt;): Match the i-th captured fragment, begins from 0
	(&amp;lt;$name;i&amp;gt;): Match the i-th captured fragment in the named group called "name", begins from 0
	(&amp;lt;$name&amp;gt;): Match any captured fragment in the named group called "name"
6) MISC
	(=regex): The prefix of the following text should match the regex, but it is not counted in the whole match (DFA incompatible)
	(!regex): Any prefix of the following text should not match the regex, and it is not counted in the whole match (DFA incompatible)
	(&amp;lt;#name&amp;gt;regex): Name the regex "name", and it applies here
	(&amp;lt;&amp;amp;name&amp;gt;): Copy the named regex "name" here and apply
&lt;/summary&gt;
&lt;/Document&gt;</Document>
      <Children>
        <VarDecl Access="Protected" Name="pure" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::pure" OverloadKey="::vl::regex::Regex::pure" Static="False">
          <Type>
            <DecorateTypeDecl Decoration="Pointer">
              <Element>
                <SubTypeDecl ReferencingNameKey="::vl::regex_internal::PureInterpretor" Name="PureInterpretor">
                  <ReferencingOverloadKeys>
                    <Key Value="::vl::regex_internal::PureInterpretor@s:vl.regex_internal.PureInterpretor" />
                  </ReferencingOverloadKeys>
                  <Parent>
                    <RefTypeDecl ReferencingNameKey="::vl::regex_internal" Name="regex_internal">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::regex_internal@ns:vl.regex_internal" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </Parent>
                </SubTypeDecl>
              </Element>
            </DecorateTypeDecl>
          </Type>
        </VarDecl>
        <VarDecl Access="Protected" Name="rich" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::rich" OverloadKey="::vl::regex::Regex::rich" Static="False">
          <Type>
            <DecorateTypeDecl Decoration="Pointer">
              <Element>
                <SubTypeDecl ReferencingNameKey="::vl::regex_internal::RichInterpretor" Name="RichInterpretor">
                  <ReferencingOverloadKeys>
                    <Key Value="::vl::regex_internal::RichInterpretor@s:vl.regex_internal.RichInterpretor" />
                  </ReferencingOverloadKeys>
                  <Parent>
                    <RefTypeDecl ReferencingNameKey="::vl::regex_internal" Name="regex_internal">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::regex_internal@ns:vl.regex_internal" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </Parent>
                </SubTypeDecl>
              </Element>
            </DecorateTypeDecl>
          </Type>
        </VarDecl>
        <FuncDecl Access="Protected" Name="Process" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Process" OverloadKey="::vl::regex::Regex::Process(&amp; const WString,bool,bool,bool,&amp; RegexMatch::List)const" Virtual="Normal" Function="Function">
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="True">
              <ReturnType>
                <RefTypeDecl Name="void" />
              </ReturnType>
              <Parameters>
                <VarDecl Access="Public" Name="text" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Process::text" OverloadKey="::vl::regex::Regex::Process(&amp; const WString,bool,bool,bool,&amp; RegexMatch::List)const::text" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <DecorateTypeDecl Decoration="Const">
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::WString" Name="WString">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::WString@s:vl.WString" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
                <VarDecl Access="Public" Name="keepEmpty" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Process::keepEmpty" OverloadKey="::vl::regex::Regex::Process(&amp; const WString,bool,bool,bool,&amp; RegexMatch::List)const::keepEmpty" Static="False">
                  <Type>
                    <RefTypeDecl Name="bool" />
                  </Type>
                </VarDecl>
                <VarDecl Access="Public" Name="keepSuccess" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Process::keepSuccess" OverloadKey="::vl::regex::Regex::Process(&amp; const WString,bool,bool,bool,&amp; RegexMatch::List)const::keepSuccess" Static="False">
                  <Type>
                    <RefTypeDecl Name="bool" />
                  </Type>
                </VarDecl>
                <VarDecl Access="Public" Name="keepFail" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Process::keepFail" OverloadKey="::vl::regex::Regex::Process(&amp; const WString,bool,bool,bool,&amp; RegexMatch::List)const::keepFail" Static="False">
                  <Type>
                    <RefTypeDecl Name="bool" />
                  </Type>
                </VarDecl>
                <VarDecl Access="Public" Name="matches" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Process::matches" OverloadKey="::vl::regex::Regex::Process(&amp; const WString,bool,bool,bool,&amp; RegexMatch::List)const::matches" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <SubTypeDecl ReferencingNameKey="::vl::regex::RegexMatch::List" Name="List">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::regex::RegexMatch::List@s:vl.regex.RegexMatch" />
                          </ReferencingOverloadKeys>
                          <Parent>
                            <RefTypeDecl ReferencingNameKey="::vl::regex::RegexMatch" Name="RegexMatch">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::regex::RegexMatch@s:vl.regex.RegexMatch" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Parent>
                        </SubTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
              </Parameters>
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="Regex" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Regex" OverloadKey="::vl::regex::Regex::Regex(&amp; const WString,bool)" Virtual="Normal" Function="Constructor">
          <Document>&lt;Document&gt;
  &lt;summary&gt;Create a regular expression.&lt;/summary&gt;
  &lt;param name="code"&gt;The regular expression in a string.&lt;/param&gt;
  &lt;param name="preferPure"&gt;Set to true to tell the Regex to use DFA if possible.&lt;/param&gt;
&lt;/Document&gt;</Document>
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="False">
              <ReturnType>
                <RefTypeDecl Name="void" />
              </ReturnType>
              <Parameters>
                <VarDecl Access="Public" Name="code" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Regex::code" OverloadKey="::vl::regex::Regex::Regex(&amp; const WString,bool)::code" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <DecorateTypeDecl Decoration="Const">
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::WString" Name="WString">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::WString@s:vl.WString" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
                <VarDecl Access="Public" Name="preferPure" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Regex::preferPure" OverloadKey="::vl::regex::Regex::Regex(&amp; const WString,bool)::preferPure" Static="False">
                  <Type>
                    <RefTypeDecl Name="bool" />
                  </Type>
                </VarDecl>
              </Parameters>
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="~Regex" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::~Regex" OverloadKey="::vl::regex::Regex::~Regex()" Virtual="Normal" Function="Destructor">
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="False">
              <ReturnType>
                <RefTypeDecl Name="void" />
              </ReturnType>
              <Parameters />
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="IsPureMatch" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::IsPureMatch" OverloadKey="::vl::regex::Regex::IsPureMatch()const" Virtual="Normal" Function="Function">
          <Document>&lt;Document&gt;
  &lt;summary&gt;Test does the Regex uses DFA to match a string.&lt;/summary&gt;
  &lt;returns&gt;Returns true if DFA is used.&lt;/returns&gt;
&lt;/Document&gt;</Document>
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="True">
              <ReturnType>
                <RefTypeDecl Name="bool" />
              </ReturnType>
              <Parameters />
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="IsPureTest" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::IsPureTest" OverloadKey="::vl::regex::Regex::IsPureTest()const" Virtual="Normal" Function="Function">
          <Document>&lt;Document&gt;
  &lt;summary&gt;Test does the Regex uses DFA to test a string. Test means ignoring all capturing requirements.&lt;/summary&gt;
  &lt;returns&gt;Returns true if DFA is used.&lt;/returns&gt;
&lt;/Document&gt;</Document>
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="True">
              <ReturnType>
                <RefTypeDecl Name="bool" />
              </ReturnType>
              <Parameters />
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="MatchHead" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::MatchHead" OverloadKey="::vl::regex::Regex::MatchHead(&amp; const WString)const" Virtual="Normal" Function="Function">
          <Document>&lt;Document&gt;
  &lt;summary&gt;Match a prefix of the text.&lt;/summary&gt;
  &lt;returns&gt;Returns the match. Returns null if failed.&lt;/returns&gt;
  &lt;param name="text"&gt;The text to match.&lt;/param&gt;
&lt;/Document&gt;</Document>
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="True">
              <ReturnType>
                <SubTypeDecl ReferencingNameKey="::vl::regex::RegexMatch::Ref" Name="Ref">
                  <ReferencingOverloadKeys>
                    <Key Value="::vl::regex::RegexMatch::Ref@s:vl.regex.RegexMatch" />
                  </ReferencingOverloadKeys>
                  <Parent>
                    <RefTypeDecl ReferencingNameKey="::vl::regex::RegexMatch" Name="RegexMatch">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::regex::RegexMatch@s:vl.regex.RegexMatch" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </Parent>
                </SubTypeDecl>
              </ReturnType>
              <Parameters>
                <VarDecl Access="Public" Name="text" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::MatchHead::text" OverloadKey="::vl::regex::Regex::MatchHead(&amp; const WString)const::text" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <DecorateTypeDecl Decoration="Const">
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::WString" Name="WString">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::WString@s:vl.WString" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
              </Parameters>
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="Match" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Match" OverloadKey="::vl::regex::Regex::Match(&amp; const WString)const" Virtual="Normal" Function="Function">
          <Document>&lt;Document&gt;
  &lt;summary&gt;Match a fragment of the text.&lt;/summary&gt;
  &lt;returns&gt;Returns the match. Returns null if failed.&lt;/returns&gt;
  &lt;param name="text"&gt;The text to match.&lt;/param&gt;
&lt;/Document&gt;</Document>
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="True">
              <ReturnType>
                <SubTypeDecl ReferencingNameKey="::vl::regex::RegexMatch::Ref" Name="Ref">
                  <ReferencingOverloadKeys>
                    <Key Value="::vl::regex::RegexMatch::Ref@s:vl.regex.RegexMatch" />
                  </ReferencingOverloadKeys>
                  <Parent>
                    <RefTypeDecl ReferencingNameKey="::vl::regex::RegexMatch" Name="RegexMatch">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::regex::RegexMatch@s:vl.regex.RegexMatch" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </Parent>
                </SubTypeDecl>
              </ReturnType>
              <Parameters>
                <VarDecl Access="Public" Name="text" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Match::text" OverloadKey="::vl::regex::Regex::Match(&amp; const WString)const::text" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <DecorateTypeDecl Decoration="Const">
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::WString" Name="WString">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::WString@s:vl.WString" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
              </Parameters>
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="TestHead" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::TestHead" OverloadKey="::vl::regex::Regex::TestHead(&amp; const WString)const" Virtual="Normal" Function="Function">
          <Document>&lt;Document&gt;
  &lt;summary&gt;Match a prefix of the text, ignoring all capturing requirements.&lt;/summary&gt;
  &lt;returns&gt;Returns true if succeeded.&lt;/returns&gt;
  &lt;param name="text"&gt;The text to match.&lt;/param&gt;
&lt;/Document&gt;</Document>
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="True">
              <ReturnType>
                <RefTypeDecl Name="bool" />
              </ReturnType>
              <Parameters>
                <VarDecl Access="Public" Name="text" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::TestHead::text" OverloadKey="::vl::regex::Regex::TestHead(&amp; const WString)const::text" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <DecorateTypeDecl Decoration="Const">
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::WString" Name="WString">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::WString@s:vl.WString" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
              </Parameters>
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="Test" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Test" OverloadKey="::vl::regex::Regex::Test(&amp; const WString)const" Virtual="Normal" Function="Function">
          <Document>&lt;Document&gt;
  &lt;summary&gt;Match a fragment of the text, ignoring all capturing requirements.&lt;/summary&gt;
  &lt;returns&gt;Returns true if succeeded.&lt;/returns&gt;
  &lt;param name="text"&gt;The text to match.&lt;/param&gt;
&lt;/Document&gt;</Document>
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="True">
              <ReturnType>
                <RefTypeDecl Name="bool" />
              </ReturnType>
              <Parameters>
                <VarDecl Access="Public" Name="text" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Test::text" OverloadKey="::vl::regex::Regex::Test(&amp; const WString)const::text" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <DecorateTypeDecl Decoration="Const">
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::WString" Name="WString">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::WString@s:vl.WString" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
              </Parameters>
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="Search" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Search" OverloadKey="::vl::regex::Regex::Search(&amp; const WString,&amp; RegexMatch::List)const" Virtual="Normal" Function="Function">
          <Document>&lt;Document&gt;
  &lt;summary&gt;Find all matched fragments of the text, returning all matched fragments.&lt;/summary&gt;
  &lt;param name="text"&gt;The text to match.&lt;/param&gt;
  &lt;param name="matches"&gt;All successful matches.&lt;/param&gt;
&lt;/Document&gt;</Document>
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="True">
              <ReturnType>
                <RefTypeDecl Name="void" />
              </ReturnType>
              <Parameters>
                <VarDecl Access="Public" Name="text" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Search::text" OverloadKey="::vl::regex::Regex::Search(&amp; const WString,&amp; RegexMatch::List)const::text" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <DecorateTypeDecl Decoration="Const">
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::WString" Name="WString">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::WString@s:vl.WString" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
                <VarDecl Access="Public" Name="matches" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Search::matches" OverloadKey="::vl::regex::Regex::Search(&amp; const WString,&amp; RegexMatch::List)const::matches" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <SubTypeDecl ReferencingNameKey="::vl::regex::RegexMatch::List" Name="List">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::regex::RegexMatch::List@s:vl.regex.RegexMatch" />
                          </ReferencingOverloadKeys>
                          <Parent>
                            <RefTypeDecl ReferencingNameKey="::vl::regex::RegexMatch" Name="RegexMatch">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::regex::RegexMatch@s:vl.regex.RegexMatch" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Parent>
                        </SubTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
              </Parameters>
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="Split" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Split" OverloadKey="::vl::regex::Regex::Split(&amp; const WString,bool,&amp; RegexMatch::List)const" Virtual="Normal" Function="Function">
          <Document>&lt;Document&gt;
  &lt;summary&gt;Split the text by matched fragments, returning all unmatched fragments.&lt;/summary&gt;
  &lt;param name="text"&gt;The text to match.&lt;/param&gt;
  &lt;param name="keepEmptyMatch"&gt;Set to true to keep all empty matches.&lt;/param&gt;
  &lt;param name="matches"&gt;All failed matches.&lt;/param&gt;
&lt;/Document&gt;</Document>
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="True">
              <ReturnType>
                <RefTypeDecl Name="void" />
              </ReturnType>
              <Parameters>
                <VarDecl Access="Public" Name="text" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Split::text" OverloadKey="::vl::regex::Regex::Split(&amp; const WString,bool,&amp; RegexMatch::List)const::text" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <DecorateTypeDecl Decoration="Const">
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::WString" Name="WString">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::WString@s:vl.WString" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
                <VarDecl Access="Public" Name="keepEmptyMatch" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Split::keepEmptyMatch" OverloadKey="::vl::regex::Regex::Split(&amp; const WString,bool,&amp; RegexMatch::List)const::keepEmptyMatch" Static="False">
                  <Type>
                    <RefTypeDecl Name="bool" />
                  </Type>
                </VarDecl>
                <VarDecl Access="Public" Name="matches" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Split::matches" OverloadKey="::vl::regex::Regex::Split(&amp; const WString,bool,&amp; RegexMatch::List)const::matches" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <SubTypeDecl ReferencingNameKey="::vl::regex::RegexMatch::List" Name="List">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::regex::RegexMatch::List@s:vl.regex.RegexMatch" />
                          </ReferencingOverloadKeys>
                          <Parent>
                            <RefTypeDecl ReferencingNameKey="::vl::regex::RegexMatch" Name="RegexMatch">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::regex::RegexMatch@s:vl.regex.RegexMatch" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Parent>
                        </SubTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
              </Parameters>
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
        <FuncDecl Access="Public" Name="Cut" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Cut" OverloadKey="::vl::regex::Regex::Cut(&amp; const WString,bool,&amp; RegexMatch::List)const" Virtual="Normal" Function="Function">
          <Document>&lt;Document&gt;
  &lt;summary&gt;Cut the text by matched fragments, returning all matched or unmatched fragments.&lt;/summary&gt;
  &lt;param name="text"&gt;The text to match.&lt;/param&gt;
  &lt;param name="keepEmptyMatch"&gt;Set to true to keep all empty matches.&lt;/param&gt;
  &lt;param name="matches"&gt;All successful and failed matches.&lt;/param&gt;
&lt;/Document&gt;</Document>
          <Type>
            <FunctionTypeDecl CallingConvention="Default" Const="True">
              <ReturnType>
                <RefTypeDecl Name="void" />
              </ReturnType>
              <Parameters>
                <VarDecl Access="Public" Name="text" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Cut::text" OverloadKey="::vl::regex::Regex::Cut(&amp; const WString,bool,&amp; RegexMatch::List)const::text" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <DecorateTypeDecl Decoration="Const">
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::WString" Name="WString">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::WString@s:vl.WString" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
                <VarDecl Access="Public" Name="keepEmptyMatch" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Cut::keepEmptyMatch" OverloadKey="::vl::regex::Regex::Cut(&amp; const WString,bool,&amp; RegexMatch::List)const::keepEmptyMatch" Static="False">
                  <Type>
                    <RefTypeDecl Name="bool" />
                  </Type>
                </VarDecl>
                <VarDecl Access="Public" Name="matches" Tags="x64, Windows;x86, Windows" NameKey="::vl::regex::Regex::Cut::matches" OverloadKey="::vl::regex::Regex::Cut(&amp; const WString,bool,&amp; RegexMatch::List)const::matches" Static="False">
                  <Type>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <SubTypeDecl ReferencingNameKey="::vl::regex::RegexMatch::List" Name="List">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::regex::RegexMatch::List@s:vl.regex.RegexMatch" />
                          </ReferencingOverloadKeys>
                          <Parent>
                            <RefTypeDecl ReferencingNameKey="::vl::regex::RegexMatch" Name="RegexMatch">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::regex::RegexMatch@s:vl.regex.RegexMatch" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Parent>
                        </SubTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </Type>
                </VarDecl>
              </Parameters>
            </FunctionTypeDecl>
          </Type>
        </FuncDecl>
      </Children>
      <BaseTypes>
        <BaseTypeDecl Access="Public" Tags="x86, Windows">
          <Type>
            <RefTypeDecl ReferencingNameKey="::vl::Object" Name="Object">
              <ReferencingOverloadKeys>
                <Key Value="::vl::Object@s:vl.Object" />
              </ReferencingOverloadKeys>
            </RefTypeDecl>
          </Type>
        </BaseTypeDecl>
        <BaseTypeDecl Access="Private" Tags="x86, Windows">
          <Type>
            <RefTypeDecl ReferencingNameKey="::vl::NotCopyable" Name="NotCopyable">
              <ReferencingOverloadKeys>
                <Key Value="::vl::NotCopyable@s:vl.NotCopyable" />
              </ReferencingOverloadKeys>
            </RefTypeDecl>
          </Type>
        </BaseTypeDecl>
      </BaseTypes>
    </ClassDecl>
  </Symbols>
</OverloadingSymbols>