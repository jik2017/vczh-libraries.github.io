<?xml version="1.0" encoding="utf-8"?>
<Namespace DisplayName="::vl::regex">
  <Overloads DisplayName="r_d function">
    <Symbol Key="::vl::regex::r_d()" UrlName="vl.regex.r_d()" Doc="false" />
  </Overloads>
  <Overloads DisplayName="r_l function">
    <Symbol Key="::vl::regex::r_l()" UrlName="vl.regex.r_l()" Doc="false" />
  </Overloads>
  <Overloads DisplayName="r_w function">
    <Symbol Key="::vl::regex::r_w()" UrlName="vl.regex.r_w()" Doc="false" />
  </Overloads>
  <Overloads DisplayName="rAnyChar function">
    <Symbol Key="::vl::regex::rAnyChar()" UrlName="vl.regex.rAnyChar()" Doc="false" />
  </Overloads>
  <Overloads DisplayName="rBegin function">
    <Symbol Key="::vl::regex::rBegin()" UrlName="vl.regex.rBegin()" Doc="false" />
  </Overloads>
  <Overloads DisplayName="rC function">
    <Symbol Key="::vl::regex::rC(wchar_t,wchar_t)" UrlName="vl.regex.rC(wchar_t,wchar_t)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="rCapture function">
    <Symbol Key="::vl::regex::rCapture(&amp; const WString,&amp; const RegexNode)" UrlName="vl.regex.rCapture(&amp; const WString,&amp; const RegexNode)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="Regex class">
    <Symbol Key="::vl::regex::Regex" UrlName="vl.regex.Regex" Doc="true" />
  </Overloads>
  <Overloads DisplayName="RegexInterTokenStateDeleter typedecl">
    <Symbol Key="::vl::regex::RegexInterTokenStateDeleter" UrlName="vl.regex.RegexInterTokenStateDeleter" Doc="false" />
  </Overloads>
  <Overloads DisplayName="RegexLexer class">
    <Symbol Key="::vl::regex::RegexLexer" UrlName="vl.regex.RegexLexer" Doc="true" />
  </Overloads>
  <Overloads DisplayName="RegexLexerColorizer class">
    <Symbol Key="::vl::regex::RegexLexerColorizer" UrlName="vl.regex.RegexLexerColorizer" Doc="true" />
  </Overloads>
  <Overloads DisplayName="RegexLexerWalker class">
    <Symbol Key="::vl::regex::RegexLexerWalker" UrlName="vl.regex.RegexLexerWalker" Doc="true" />
  </Overloads>
  <Overloads DisplayName="RegexMatch class">
    <Symbol Key="::vl::regex::RegexMatch" UrlName="vl.regex.RegexMatch" Doc="true" />
  </Overloads>
  <Overloads DisplayName="RegexNode class">
    <Symbol Key="::vl::regex::RegexNode" UrlName="vl.regex.RegexNode" Doc="false" />
  </Overloads>
  <Overloads DisplayName="RegexProc struct">
    <Symbol Key="::vl::regex::RegexProc" UrlName="vl.regex.RegexProc" Doc="true" />
  </Overloads>
  <Overloads DisplayName="RegexProcessingToken struct">
    <Symbol Key="::vl::regex::RegexProcessingToken" UrlName="vl.regex.RegexProcessingToken" Doc="true" />
  </Overloads>
  <Overloads DisplayName="RegexString class">
    <Symbol Key="::vl::regex::RegexString" UrlName="vl.regex.RegexString" Doc="true" />
  </Overloads>
  <Overloads DisplayName="RegexToken struct">
    <Symbol Key="::vl::regex::RegexToken" UrlName="vl.regex.RegexToken" Doc="true" />
  </Overloads>
  <Overloads DisplayName="RegexTokenColorizeProc typedecl">
    <Symbol Key="::vl::regex::RegexTokenColorizeProc" UrlName="vl.regex.RegexTokenColorizeProc" Doc="false" />
  </Overloads>
  <Overloads DisplayName="RegexTokenExtendProc typedecl">
    <Symbol Key="::vl::regex::RegexTokenExtendProc" UrlName="vl.regex.RegexTokenExtendProc" Doc="false" />
  </Overloads>
  <Overloads DisplayName="RegexTokens class">
    <Symbol Key="::vl::regex::RegexTokens" UrlName="vl.regex.RegexTokens" Doc="true" />
  </Overloads>
  <Overloads DisplayName="rEnd function">
    <Symbol Key="::vl::regex::rEnd()" UrlName="vl.regex.rEnd()" Doc="false" />
  </Overloads>
  <Overloads DisplayName="rMatch function">
    <Symbol Key="::vl::regex::rMatch(&amp; const WString,vint)" UrlName="vl.regex.rMatch(&amp; const WString,vint)" Doc="false" />
    <Symbol Key="::vl::regex::rMatch(vint)" UrlName="vl.regex.rMatch(vint)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="rUsing function">
    <Symbol Key="::vl::regex::rUsing(&amp; const WString)" UrlName="vl.regex.rUsing(&amp; const WString)" Doc="false" />
  </Overloads>
</Namespace>