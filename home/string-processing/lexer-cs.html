<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Gaclib -- Home -- Lexical analyzer with non-regex tokens</title>
<link rel="shortcut icon" href="../../favicon.ico">
<link rel="stylesheet" type="text/css" href="../../global.css">
<link rel="stylesheet" type="text/css" href="../../article.css">
<link rel="stylesheet" type="text/css" href="../../navigation.css">
<link rel="stylesheet" type="text/css" href="../../category.css">
<script src="../../scripts/rootView.js"></script>
<script src="../../scripts/homeView.js"></script>
<script src="../../scripts/homeCategoryArticleView.js"></script>

</head>
<body>
<div id="MVC-ViewContainer"></div>
<script lang="javascript">
{
  const mvcModel = {
  "path": [
    "string-processing",
    "lexer-cs"
  ]
};
  const mvcViews = [
  {
    "targetObject": "MVC-ViewContainer",
    "viewName": "Gaclib-RootView"
  },
  {
    "targetObject": "rootViewContainer",
    "viewName": "Gaclib-HomeView"
  },
  {
    "targetObject": "homeViewContainer",
    "viewName": "Gaclib-HomeCategoryArticleView"
  }
];
  const activeButton = "Home";
  const activeCategory = "String";
  const homeArticle = {
  "index": false,
  "numberBeforeTitle": false,
  "topic": {
    "kind": "Topic",
    "title": "Welcome to Gaclib!",
    "content": [
      {
        "kind": "Paragraph",
        "content": [
          {
            "kind": "Text",
            "text": "\r\n            Gaclib is a GPU accelerated C++ User Interface library.\r\n            It is flexible, customizable with rich amount of built-in layout and controls.\r\n            It also supports control templates, list item templates, MVVM, localization, animation, etc.\r\n            More importantly, even if the UI is very complex, it still has good performance in interaction.\r\n            You can find it at "
          },
          {
            "kind": "PageLink",
            "href": "https://github.com/vczh-libraries/Release",
            "content": [
              {
                "kind": "Text",
                "text": "github"
              }
            ]
          },
          {
            "kind": "Text",
            "text": ".\r\n            This library provide many useful features.\r\n            If you don't need all features,\r\n            you can just use a subset of released C++ files to reduce the size of the executable.\r\n        "
          }
        ]
      }
    ]
  }
};
  const categoryArticle = {
  "index": false,
  "numberBeforeTitle": false,
  "topic": {
    "kind": "Topic",
    "title": "Lexical analyzer with non-regex tokens",
    "content": [
      {
        "kind": "Paragraph",
        "content": [
          {
            "kind": "Text",
            "text": "\r\n            When regular expression is not enough to define a token,\r\n            you can register a callback to modify the token,\r\n            it is called on every recognized token.\r\n            For colorization, a token could be provided in multiple line buffers,\r\n            the callback is also given the information to handle such case.\r\n        "
          }
        ]
      },
      {
        "kind": "Paragraph",
        "content": [
          {
            "kind": "Text",
            "text": "\r\n            Context sensitive colorization is also a very powerful feature provided by "
          },
          {
            "kind": "Strong",
            "content": [
              {
                "kind": "Text",
                "text": "RegexLexer"
              }
            ]
          },
          {
            "kind": "Text",
            "text": ".\r\n        "
          }
        ]
      },
      {
        "kind": "Paragraph",
        "content": [
          {
            "kind": "Program",
            "code": "struct InterTokenState\r\n{\r\n    WString postfix;\r\n};\r\n\r\nvoid Deleter(void* interStateDeleter)\r\n{\r\n    delete (InterTokenState*)interStateDeleter;\r\n}\r\n\r\nvoid ExtendProc(void* argument, const wchar_t* reading, vint length, bool completeText, RegexProcessingToken& processingToken)\r\n{\r\n    WString readingBuffer = length == -1 ? WString(reading, false) : WString(reading, length);\r\n    reading = readingBuffer.Buffer();\r\n\r\n    if (processingToken.token == 2 || processingToken.token == 3)\r\n    {\r\n        WString postfix;\r\n        if (processingToken.interTokenState)\r\n        {\r\n            postfix = ((InterTokenState*)processingToken.interTokenState)->postfix;\r\n        }\r\n        else\r\n        {\r\n            postfix = L\")\" + WString(reading + 2, processingToken.length - 3) + L\"\\\"\";\r\n        }\r\n\r\n        auto find = wcsstr(reading, postfix.Buffer());\r\n        if (find)\r\n        {\r\n            processingToken.length = (vint)(find - reading) + postfix.Length();\r\n            processingToken.completeToken = true;\r\n            processingToken.interTokenState = nullptr;\r\n        }\r\n        else\r\n        {\r\n            processingToken.length = readingBuffer.Length();\r\n            processingToken.token = 3;\r\n            processingToken.completeToken = false;\r\n\r\n            if (!completeText && !processingToken.interTokenState)\r\n            {\r\n                auto state = new InterTokenState;\r\n                state->postfix = postfix;\r\n                processingToken.interTokenState = state;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\nList<WString> codes;\r\ncodes.Add(L\"/d+\");\r\ncodes.Add(L\"\\\"[^\\\"]*\\\"\");\r\ncodes.Add(L\"/$\\\"=*/(\");\r\n\r\nRegexProc proc;\r\nproc.deleter = Deleter;\r\nproc.extendProc = ExtendProc;\r\nRegexLexer lexer(codes, proc);\r\n\r\nWString input = LR\"test_input(\r\n    123 456\r\n    \"simple text\"\r\n    $\"===(\r\n    abcde\r\n    )===\"\r\n)test_input\";\r\n\r\nList<RegexToken> tokens;\r\nCopyFrom(tokens, lexer.Parse(input));\r\n}",
            "language": "C++"
          }
        ]
      }
    ]
  }
};
  window["MVC-Resources.mvcModel"] = mvcModel;
  window["MVC-Resources.mvcViews"] = mvcViews;
  window["MVC-Resources.activeButton"] = activeButton;
  window["MVC-Resources.activeCategory"] = activeCategory;
  window["MVC-Resources.homeArticle"] = homeArticle;
  window["MVC-Resources.categoryArticle"] = categoryArticle;
  for (const view of mvcViews) {
    window[view.viewName].renderView(mvcModel, document.getElementById(view.targetObject));
  }
  const renderedScriptTags = document.getElementById("MVC-ViewContainer").getElementsByTagName("script");
  for (const scriptTag of renderedScriptTags) {
    eval(
      "(function(){" + scriptTag.innerHTML + "})()"
    );
  }
}
</script>
</body>
</html>
